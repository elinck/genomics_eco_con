[
  {
    "objectID": "genomics.html",
    "href": "genomics.html",
    "title": "genomics",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "genomics.html#quarto",
    "href": "genomics.html#quarto",
    "title": "genomics",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "syllabus/01_syllabus.html",
    "href": "syllabus/01_syllabus.html",
    "title": "BIOE 591: Genomics for Ecology and Conservation",
    "section": "",
    "text": "Course: BIOE 591 (3 Credits)\nPrerequisite: BIOB480/BIOE548 or consent of instructor\nMeeting Time: T/TR 10:50 AM – 12:05 PM\nPlace: TBD\nInstructor: Dr. Ethan Linck (ethan.linck@montana.edu; 406-994-2024)\nOffice Hours: 1:00 PM – 2:30 T/TR\nMaterials: A laptop (tablets will not suffice)\n\n\nApplication of genomics methods to conservation, ecology, and evolution. Students gain familiarity with the basic tools and techniques of computational biology and genomics through case studies from the primary literature and analysis of empirical datasets. Examples and questions relevant to conservation biology and fish and wildlife management are emphasized.\n\n\n\nThe development of affordable high-throughput sequencing technology in the 2000s and 2010s revolutionized the ability of molecular ecologists, wildlife and conservation biologists, and other environmental scientists to assay genome-wide DNA sequence variation from nonmodel organisms. Genomics methods are now commonly used to study everything from the dietary preferences of sturgeon to genes underpinning local adaptation in wolves, but can be difficult to apply or interpret without specialist training. This course provides a hands-on introduction to the use of genomics in ecology, conservation, and related fields. Students will gain hands-on experience with computational biology, analyzing empirical genomic datasets with commonly applied software on a high-performance computing cluster. Reading assignments from the primary literature will demonstrate the use of focal software packages while emphasizing case studies relevant to conservation biology and fish and wildlife management.\n\n\n\nThe course will be offered as a mix of short lectures or demonstrations and discussions on reading assignments (typically Tuesdays) and supervised computer lab activities (typically Thursdays).\n\n\n\n\nCompare high-throughput sequencing approaches;\nEvaluate genomics methods sections in the primary literature;\nApply basic tools and techniques from computational biology;\nAnalyze empirical datasets with genomics softwate;\nCreate scripts for custom data analysis tasks.\n\n\n\n\nYour grade will be calculated as the fraction of points earned out of a total of 200. 120 points will come from completing lab assignments (10 points each; turned in the following class period as homework), 60 will come from posting comments or questions in Canvas discussion threads on assigned reading (5 points each; engagement with 12/14 papers needed), and 20 points will come from participation (based on attendance, clasroom participation, and assessment completion).\n\n\n\n\n\n\nWeek\nTopic\nAssignments\n\n\n\n\n1/12 - 1/16\nIntroduction and Review\n\nPreliminary Assessment\n\n\n\n1/19 - 1/23\nWhat is Genomics?\n\nHohenlohe et al. 2020\nHudson 2008*\nFelsenstein rant #1\n\n\n\n1/26 - 1/30\nComputational Biology Basics\n\nBraga et al. 2023\nSet up GitHub profiles with markdown READMEs (HW1)\n\n\n\n2/2 - 2/6\nComputing Clusters and the Command Line\n\nInstall sofware with mamba environment manager\nbash shell scripting activity (HW2)\n\n\n\n2/9 - 2/13\nSequencing strategies and\nShort Read Quality Control\n\nWatch Illumina video\nFuentes-Pardo et al. 2017\nFastQC Read filtering activity (HW3)\n\n\n\n2/16 - 2/20\neDNA and Metabarcoding\n\nLeempole et al. 2020\nBLAST activity (HW4)\n\n\n\n3/2 - 3/6\nPipelines and Genome Assembly\n\nEkblom & Wolf 2014\nSnakemake activity (HW5)\n\n\n\n3/9 - 3/13\nVariant Calling and Filtering\n\nShafer et al. 2017\nvcftools filtering activity (HW6)\n\n\n\n3/16 - 3/20\nSpring Break\n\n\n\n3/23 - 3/27\nKinship and Inbreeding\n\nHauser et al. 2022\nNgsRelate activity (HW7)\n\n\n\n3/30 - 4/3\nGenetic Diversity and Population Structure\n\nLinck & Battey 2019\nadegenet activity (HW8)\n\n\n\n4/6 - 4/10\nIntrogression and Hybridization\n\nMandeville et al. 2019\nentropy admixture activity (HW9)\n\n\n\n4/13 - 4/17\nPhylogenetics and Conservation Units\n\nLinck et al. 2019\nSVDquartets activity (HW10)\n\n\n\n4/20 - 4/24\nSimulations and Demographic History\n\nHoey et al. 2022\nCapblancq et al. 2020*\nfastsimcoal2 activity (HW11)\n\n\n\n4/27 - 5/1\nDetecting Natural Selection\n\nSchweizer et al. 2016\nbayenv activity (HW12)\n\n\n\n5/4 - 5/8\nFinals Week\n\n\n\n\n* denotes an optional reading assignment\n\n\n\n\nHohenlohe, P. A., Funk, W. C., & Rajora, O. P. (2021). Population genomics for wildlife conservation and management. Molecular Ecology, 30(1), 62-82.\nHudson, M. E. (2008). Sequencing breakthroughs for genomic ecology and evolutionary biology. Molecular Ecology Resources, 8(1), 3-17.\nhttps://felsenst.github.io/rants.html\nBraga, P. H. P., Hébert, K., Hudgins, E. J., Scott, E. R., Edwards, B. P., Sanchez Reyes, L. L., … & Crystal‐Ornelas, R. (2023). Not just for programmers: How GitHub can accelerate collaborative and reproducible research in ecology and evolution. Methods in Ecology and Evolution, 14(6), 1364-1380.\nFuentes‐Pardo, A. P., & Ruzzante, D. E. (2017). Whole‐genome sequencing approaches for conservation biology: Advantages, limitations and practical recommendations. Molecular Ecology, 26(20), 5369-5406.\nLeempoel, K., Hebert, T., & Hadly, E. A. (2020). A comparison of eDNA to camera trapping for assessment of terrestrial mammal diversity. Proceedings of the Royal Society B, 287(1918), 20192353.\nEkblom, R., & Wolf, J. B. (2014). A field guide to whole‐genome sequencing, assembly and annotation. Evolutionary Applications, 7(9), 1026-1042.\nShafer, A. B., Peart, C. R., Tusso, S., Maayan, I., Brelsford, A., Wheat, C. W., & Wolf, J. B. (2017). Bioinformatic processing of RAD‐seq data dramatically impacts downstream population genetic inference. Methods in Ecology and Evolution, 8(8), 907-917.\nHauser, S. S., Galla, S. J., Putnam, A. S., Steeves, T. E., & Latch, E. K. (2022). Comparing genome‐based estimates of relatedness for use in pedigree‐based conservation management. Molecular Ecology Resources, 22(7), 2546-2558.\nLinck, E., & Battey, C. J. (2019). Minor allele frequency thresholds strongly affect population structure inference with genomic data sets. Molecular Ecology Resources, 19(3), 639-647.\nLinck, E., Epperly, K., Van Els, P., Spellman, G. M., Bryson Jr, R. W., McCormack, J. E., … & Klicka, J. (2019). Dense geographic and genomic sampling reveals paraphyly and a cryptic lineage in a classic sibling species complex. Systematic Biology, 68(6), 956-966.\nHoey, J. A., Able, K. W., & Pinsky, M. L. (2022). Genetic decline and recovery of a demographically rebuilt fishery species. Molecular Ecology, 31(22), 5684-5698.\nCapblancq, T., Butnor, J. R., Deyoung, S., Thibault, E., Munson, H., Nelson, D. M., … & Keller, S. R. (2020). Whole‐exome sequencing reveals a long‐term decline in effective population size of red spruce (Picea rubens). Evolutionary Applications, 13(9), 2190-2205.\nSchweizer, R. M., Vonholdt, B. M., Harrigan, R., Knowles, J. C., Musiani, M., Coltman, D., … & Wayne, R. K. (2016). Genetic subdivision and candidate genes under selection in North American grey wolves. Molecular Ecology, 25(1), 380-402.\n\n\n\n\nMSU’s registration processes can be found on the Registrar’s website. January 27th is the last day to drop online; February 3rd is the last day to drop without a ‘W’ on your transcript; April 15th is the last day to drop with a ‘W’ on your transcript.\n\n\n\nGenerative AI tools are permitted to help debug code; they are not permitted as a shortcut to learning functions or commands from software documentation, and especially not permitted for summarizing reading assignments, where the point of the exercise is to become comfortable interpreting the technical genomics literature. I will not spend my time actively policing their use, but if detected, I will consider it academic misconduct.\n\n\n\nPlease do not come to campus if you are sick! I trust you will only miss class when absolutely necessary, and do not need extensive explanations for absences. However, please notify me as soon as practical, so that we can figure appropriate accommodations.\n\n\n\nI support an inclusive learning environment where diversity and individual differences are understood, respected, appreciated, and recognized as a source of strength. We expect that students, faculty, administrators and staff at MSU will respect differences and demonstrate diligence in understanding how other peoples’ perspectives, behaviors, and worldviews may be different from their own.\n\n\n\nIf you are a student with a disability and wish to use your approved accommodations for this course, please contact me during my office hours to discuss. Please have your Accommodation Notification or Blue Card available for verification of accommodations. Accommodations are approved through the Office of Disability Services located in SUB 174. Please see Disability Services for more information."
  },
  {
    "objectID": "syllabus/01_syllabus.html#catalog-description",
    "href": "syllabus/01_syllabus.html#catalog-description",
    "title": "BIOE 591: Genomics for Ecology and Conservation",
    "section": "",
    "text": "Application of genomics methods to conservation, ecology, and evolution. Students gain familiarity with the basic tools and techniques of computational biology and genomics through case studies from the primary literature and analysis of empirical datasets. Examples and questions relevant to conservation biology and fish and wildlife management are emphasized."
  },
  {
    "objectID": "syllabus/01_syllabus.html#overview",
    "href": "syllabus/01_syllabus.html#overview",
    "title": "BIOE 591: Genomics for Ecology and Conservation",
    "section": "",
    "text": "The development of affordable high-throughput sequencing technology in the 2000s and 2010s revolutionized the ability of molecular ecologists, wildlife and conservation biologists, and other environmental scientists to assay genome-wide DNA sequence variation from nonmodel organisms. Genomics methods are now commonly used to study everything from the dietary preferences of sturgeon to genes underpinning local adaptation in wolves, but can be difficult to apply or interpret without specialist training. This course provides a hands-on introduction to the use of genomics in ecology, conservation, and related fields. Students will gain hands-on experience with computational biology, analyzing empirical genomic datasets with commonly applied software on a high-performance computing cluster. Reading assignments from the primary literature will demonstrate the use of focal software packages while emphasizing case studies relevant to conservation biology and fish and wildlife management."
  },
  {
    "objectID": "syllabus/01_syllabus.html#course-organization-and-format",
    "href": "syllabus/01_syllabus.html#course-organization-and-format",
    "title": "BIOE 591: Genomics for Ecology and Conservation",
    "section": "",
    "text": "The course will be offered as a mix of short lectures or demonstrations and discussions on reading assignments (typically Tuesdays) and supervised computer lab activities (typically Thursdays)."
  },
  {
    "objectID": "syllabus/01_syllabus.html#learning-outcomes",
    "href": "syllabus/01_syllabus.html#learning-outcomes",
    "title": "BIOE 591: Genomics for Ecology and Conservation",
    "section": "",
    "text": "Compare high-throughput sequencing approaches;\nEvaluate genomics methods sections in the primary literature;\nApply basic tools and techniques from computational biology;\nAnalyze empirical datasets with genomics softwate;\nCreate scripts for custom data analysis tasks."
  },
  {
    "objectID": "syllabus/01_syllabus.html#grading",
    "href": "syllabus/01_syllabus.html#grading",
    "title": "BIOE 591: Genomics for Ecology and Conservation",
    "section": "",
    "text": "Your grade will be calculated as the fraction of points earned out of a total of 200. 120 points will come from completing lab assignments (10 points each; turned in the following class period as homework), 60 will come from posting comments or questions in Canvas discussion threads on assigned reading (5 points each; engagement with 12/14 papers needed), and 20 points will come from participation (based on attendance, clasroom participation, and assessment completion)."
  },
  {
    "objectID": "syllabus/01_syllabus.html#schedule",
    "href": "syllabus/01_syllabus.html#schedule",
    "title": "BIOE 591: Genomics for Ecology and Conservation",
    "section": "",
    "text": "Week\nTopic\nAssignments\n\n\n\n\n1/12 - 1/16\nIntroduction and Review\n\nPreliminary Assessment\n\n\n\n1/19 - 1/23\nWhat is Genomics?\n\nHohenlohe et al. 2020\nHudson 2008*\nFelsenstein rant #1\n\n\n\n1/26 - 1/30\nComputational Biology Basics\n\nBraga et al. 2023\nSet up GitHub profiles with markdown READMEs (HW1)\n\n\n\n2/2 - 2/6\nComputing Clusters and the Command Line\n\nInstall sofware with mamba environment manager\nbash shell scripting activity (HW2)\n\n\n\n2/9 - 2/13\nSequencing strategies and\nShort Read Quality Control\n\nWatch Illumina video\nFuentes-Pardo et al. 2017\nFastQC Read filtering activity (HW3)\n\n\n\n2/16 - 2/20\neDNA and Metabarcoding\n\nLeempole et al. 2020\nBLAST activity (HW4)\n\n\n\n3/2 - 3/6\nPipelines and Genome Assembly\n\nEkblom & Wolf 2014\nSnakemake activity (HW5)\n\n\n\n3/9 - 3/13\nVariant Calling and Filtering\n\nShafer et al. 2017\nvcftools filtering activity (HW6)\n\n\n\n3/16 - 3/20\nSpring Break\n\n\n\n3/23 - 3/27\nKinship and Inbreeding\n\nHauser et al. 2022\nNgsRelate activity (HW7)\n\n\n\n3/30 - 4/3\nGenetic Diversity and Population Structure\n\nLinck & Battey 2019\nadegenet activity (HW8)\n\n\n\n4/6 - 4/10\nIntrogression and Hybridization\n\nMandeville et al. 2019\nentropy admixture activity (HW9)\n\n\n\n4/13 - 4/17\nPhylogenetics and Conservation Units\n\nLinck et al. 2019\nSVDquartets activity (HW10)\n\n\n\n4/20 - 4/24\nSimulations and Demographic History\n\nHoey et al. 2022\nCapblancq et al. 2020*\nfastsimcoal2 activity (HW11)\n\n\n\n4/27 - 5/1\nDetecting Natural Selection\n\nSchweizer et al. 2016\nbayenv activity (HW12)\n\n\n\n5/4 - 5/8\nFinals Week\n\n\n\n\n* denotes an optional reading assignment"
  },
  {
    "objectID": "syllabus/01_syllabus.html#reading-list",
    "href": "syllabus/01_syllabus.html#reading-list",
    "title": "BIOE 591: Genomics for Ecology and Conservation",
    "section": "",
    "text": "Hohenlohe, P. A., Funk, W. C., & Rajora, O. P. (2021). Population genomics for wildlife conservation and management. Molecular Ecology, 30(1), 62-82.\nHudson, M. E. (2008). Sequencing breakthroughs for genomic ecology and evolutionary biology. Molecular Ecology Resources, 8(1), 3-17.\nhttps://felsenst.github.io/rants.html\nBraga, P. H. P., Hébert, K., Hudgins, E. J., Scott, E. R., Edwards, B. P., Sanchez Reyes, L. L., … & Crystal‐Ornelas, R. (2023). Not just for programmers: How GitHub can accelerate collaborative and reproducible research in ecology and evolution. Methods in Ecology and Evolution, 14(6), 1364-1380.\nFuentes‐Pardo, A. P., & Ruzzante, D. E. (2017). Whole‐genome sequencing approaches for conservation biology: Advantages, limitations and practical recommendations. Molecular Ecology, 26(20), 5369-5406.\nLeempoel, K., Hebert, T., & Hadly, E. A. (2020). A comparison of eDNA to camera trapping for assessment of terrestrial mammal diversity. Proceedings of the Royal Society B, 287(1918), 20192353.\nEkblom, R., & Wolf, J. B. (2014). A field guide to whole‐genome sequencing, assembly and annotation. Evolutionary Applications, 7(9), 1026-1042.\nShafer, A. B., Peart, C. R., Tusso, S., Maayan, I., Brelsford, A., Wheat, C. W., & Wolf, J. B. (2017). Bioinformatic processing of RAD‐seq data dramatically impacts downstream population genetic inference. Methods in Ecology and Evolution, 8(8), 907-917.\nHauser, S. S., Galla, S. J., Putnam, A. S., Steeves, T. E., & Latch, E. K. (2022). Comparing genome‐based estimates of relatedness for use in pedigree‐based conservation management. Molecular Ecology Resources, 22(7), 2546-2558.\nLinck, E., & Battey, C. J. (2019). Minor allele frequency thresholds strongly affect population structure inference with genomic data sets. Molecular Ecology Resources, 19(3), 639-647.\nLinck, E., Epperly, K., Van Els, P., Spellman, G. M., Bryson Jr, R. W., McCormack, J. E., … & Klicka, J. (2019). Dense geographic and genomic sampling reveals paraphyly and a cryptic lineage in a classic sibling species complex. Systematic Biology, 68(6), 956-966.\nHoey, J. A., Able, K. W., & Pinsky, M. L. (2022). Genetic decline and recovery of a demographically rebuilt fishery species. Molecular Ecology, 31(22), 5684-5698.\nCapblancq, T., Butnor, J. R., Deyoung, S., Thibault, E., Munson, H., Nelson, D. M., … & Keller, S. R. (2020). Whole‐exome sequencing reveals a long‐term decline in effective population size of red spruce (Picea rubens). Evolutionary Applications, 13(9), 2190-2205.\nSchweizer, R. M., Vonholdt, B. M., Harrigan, R., Knowles, J. C., Musiani, M., Coltman, D., … & Wayne, R. K. (2016). Genetic subdivision and candidate genes under selection in North American grey wolves. Molecular Ecology, 25(1), 380-402."
  },
  {
    "objectID": "syllabus/01_syllabus.html#drop-add-policy",
    "href": "syllabus/01_syllabus.html#drop-add-policy",
    "title": "BIOE 591: Genomics for Ecology and Conservation",
    "section": "",
    "text": "MSU’s registration processes can be found on the Registrar’s website. January 27th is the last day to drop online; February 3rd is the last day to drop without a ‘W’ on your transcript; April 15th is the last day to drop with a ‘W’ on your transcript."
  },
  {
    "objectID": "syllabus/01_syllabus.html#generative-ai",
    "href": "syllabus/01_syllabus.html#generative-ai",
    "title": "BIOE 591: Genomics for Ecology and Conservation",
    "section": "",
    "text": "Generative AI tools are permitted to help debug code; they are not permitted as a shortcut to learning functions or commands from software documentation, and especially not permitted for summarizing reading assignments, where the point of the exercise is to become comfortable interpreting the technical genomics literature. I will not spend my time actively policing their use, but if detected, I will consider it academic misconduct."
  },
  {
    "objectID": "syllabus/01_syllabus.html#attendance-policy",
    "href": "syllabus/01_syllabus.html#attendance-policy",
    "title": "BIOE 591: Genomics for Ecology and Conservation",
    "section": "",
    "text": "Please do not come to campus if you are sick! I trust you will only miss class when absolutely necessary, and do not need extensive explanations for absences. However, please notify me as soon as practical, so that we can figure appropriate accommodations."
  },
  {
    "objectID": "syllabus/01_syllabus.html#inclusivity-statement",
    "href": "syllabus/01_syllabus.html#inclusivity-statement",
    "title": "BIOE 591: Genomics for Ecology and Conservation",
    "section": "",
    "text": "I support an inclusive learning environment where diversity and individual differences are understood, respected, appreciated, and recognized as a source of strength. We expect that students, faculty, administrators and staff at MSU will respect differences and demonstrate diligence in understanding how other peoples’ perspectives, behaviors, and worldviews may be different from their own."
  },
  {
    "objectID": "syllabus/01_syllabus.html#syllabus-language-for-students-with-disabilities",
    "href": "syllabus/01_syllabus.html#syllabus-language-for-students-with-disabilities",
    "title": "BIOE 591: Genomics for Ecology and Conservation",
    "section": "",
    "text": "If you are a student with a disability and wish to use your approved accommodations for this course, please contact me during my office hours to discuss. Please have your Accommodation Notification or Blue Card available for verification of accommodations. Accommodations are approved through the Office of Disability Services located in SUB 174. Please see Disability Services for more information."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BIOE591: Genomics for Ecology & Conservation",
    "section": "",
    "text": "Course: BIOE 591 (3 Credits)\nPrerequisite: BIOB480/BIOE548 or consent of instructor\nMeeting Time: T/TR 1:40 PM – 2:55 PM\nPlace: Wilson 1-154\nInstructor: Dr. Ethan Linck (ethan.linck@montana.edu; 406-994-2024)\nOffice Hours: 1:00 PM – 2:30 T/TR\nMaterials: A laptop (tablets will not suffice). Windows users will need to download and install Git for Windows as a Unix shell emulator."
  },
  {
    "objectID": "index.html#catalog-description",
    "href": "index.html#catalog-description",
    "title": "BIOE591: Genomics for Ecology & Conservation",
    "section": "Catalog Description",
    "text": "Catalog Description\nApplication of genomics methods to conservation, ecology, and evolution. Students gain familiarity with the basic tools and techniques of computational biology and genomics through case studies from the primary literature and analysis of empirical datasets. Examples and questions relevant to conservation biology and fish and wildlife management are emphasized."
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "BIOE591: Genomics for Ecology & Conservation",
    "section": "Overview",
    "text": "Overview\nThe development of affordable high-throughput sequencing technology in the 2000s and 2010s revolutionized the ability of molecular ecologists, wildlife and conservation biologists, and other environmental scientists to assay genome-wide DNA sequence variation from nonmodel organisms. Genomics methods are now commonly used to study everything from the dietary preferences of sturgeon to genes underpinning local adaptation in wolves, but can be difficult to apply or interpret without specialist training. This course provides a hands-on introduction to the use of genomics in ecology, conservation, and related fields. Students will gain hands-on experience with computational biology, analyzing empirical genomic datasets with commonly applied software on a high-performance computing cluster. Reading assignments from the primary literature will demonstrate the use of focal software packages while emphasizing case studies relevant to conservation biology and fish and wildlife management."
  },
  {
    "objectID": "index.html#course-organization-and-format",
    "href": "index.html#course-organization-and-format",
    "title": "BIOE591: Genomics for Ecology & Conservation",
    "section": "Course Organization and Format",
    "text": "Course Organization and Format\nThe course will be offered as a mix of short lectures or demonstrations and discussions on reading assignments (typically Tuesdays) and supervised computer lab activities (typically Thursdays)."
  },
  {
    "objectID": "index.html#learning-outcomes",
    "href": "index.html#learning-outcomes",
    "title": "BIOE591: Genomics for Ecology & Conservation",
    "section": "Learning Outcomes",
    "text": "Learning Outcomes\n\nCompare high-throughput sequencing approaches;\nEvaluate genomics methods sections in the primary literature;\nApply basic tools and techniques from computational biology;\nAnalyze empirical datasets with genomics softwate;\nCreate scripts for custom data analysis tasks."
  },
  {
    "objectID": "index.html#grading",
    "href": "index.html#grading",
    "title": "BIOE591: Genomics for Ecology & Conservation",
    "section": "Grading",
    "text": "Grading\nYour grade will be calculated as the fraction of points earned out of a total of 200. 120 points will come from completing lab assignments (10 points each; turned in the following class period as homework), 60 will come from posting comments or questions in Canvas discussion threads on assigned reading (5 points each; engagement with 12/14 papers needed), and 20 points will come from participation (based on attendance, leading at least one paper discussion and participating in the classroom, and completing the assessment)."
  },
  {
    "objectID": "index.html#resources",
    "href": "index.html#resources",
    "title": "BIOE591: Genomics for Ecology & Conservation",
    "section": "Resources",
    "text": "Resources\nI assume a solid grasp of basic genetics and evolution. If you consider yourself rusty in these areas, I recommend reviewing the lecture notes from my Conservation Genetics course (BIOB480 / BIOE548). I take for granted that you will have computer skills typical of a first-year graduate student in the middle of the third decade of the 21st century. This means: proficiency with what Gotelli calls the “unholy trinity” of M.S. Word, Excel and Powerpoint; a knowledge of basic computing hardware and operating systems; a knowledge of where to find things on your computer; and some background with scientific programming, even if shallow.\nThroughout the semester, you will likely find yourself resorting to Google, ChatGPT, and other resources to help run software and troubleshoot error messages. The following cheat sheets, tutorials and courses may also be of interest:\n\nOfficial GitHub Cheatsheet\n\nGit Beginner Cheatsheet\nCommand Line Cheatsheet #1\nCommand Line Cheatsheet #2\nSoftware Carpentry: The Unix Shell\nSoftware Carpentry: Programming with Python\nSoftware Carpentry: R for Reproducible Scientfic Analysis\nSoftware Carpentry: Snakemake for Bioinformatics\nThe Caprentries Incubator: Getting Started with Mamba\n\nHPC Carpentry\n\nThe Biologists’ Guide to Computing"
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "BIOE591: Genomics for Ecology & Conservation",
    "section": "Schedule",
    "text": "Schedule\n\n\n\nWeek\nTopic\nAssignments\n\n\n\n\n1/12 - 1/16\nWhat is Genomics?\n\nPreliminary Assessment\nHohenlohe et al. 2020 (pdf)\nFelsenstein rant #1\n\n\n\n1/19 - 1/23\nSoftware Installation & the Command Line\n\nMarkdown & Command Line Basics (HW1)\nSandve et al. 2013 (pdf)\nBrandies & Hogg 2021 (pdf)\n\n\n\n1/26 - 1/30\nVersion Control with Git & Github\n\nGit & GitHub Basics (HW2)\nBlischak et al. 2016 (pdf)\nBraga et al. 2023 (pdf)\n\n\n\n2/2 - 2/6\nComputing Clusters\n\n\n\n2/9 - 2/13\nSequencing strategies and Short Read Quality Control\n\n\n\n2/16 - 2/20\neDNA and Metabarcoding\n\n\n\n3/2 - 3/6\nPipelines and Genome Assembly\n\n\n\n3/9 - 3/13\nVariant Calling and Filtering\n\n\n\n3/16 - 3/20\nSpring Break\n\n\n\n3/23 - 3/27\nKinship and Inbreeding\n\n\n\n3/30 - 4/3\nGenetic Diversity and Population Structure\n\n\n\n4/6 - 4/10\nIntrogression and Hybridization\n\n\n\n4/13 - 4/17\nPhylogenetics and Conservation Units\n\n\n\n4/20 - 4/24\nSimulations and Demographic History\n\n\n\n4/27 - 5/1\nDetecting Natural Selection\n\n\n\n5/4 - 5/8\nFinals Week"
  },
  {
    "objectID": "index.html#drop-add-policy",
    "href": "index.html#drop-add-policy",
    "title": "BIOE591: Genomics for Ecology & Conservation",
    "section": "Drop / Add Policy",
    "text": "Drop / Add Policy\nMSU’s registration processes can be found on the Registrar’s website. January 27th is the last day to drop online; February 3rd is the last day to drop without a ‘W’ on your transcript; April 15th is the last day to drop with a ‘W’ on your transcript."
  },
  {
    "objectID": "index.html#generative-ai",
    "href": "index.html#generative-ai",
    "title": "BIOE591: Genomics for Ecology & Conservation",
    "section": "Generative AI",
    "text": "Generative AI\nGenerative AI tools are permitted to help debug code; they are not permitted as a shortcut to learning functions or commands from software documentation, and especially not permitted for summarizing reading assignments, where the point of the exercise is to become comfortable interpreting the technical genomics literature. I will not spend my time actively policing their use, but if detected, I will consider it academic misconduct."
  },
  {
    "objectID": "index.html#attendance-policy",
    "href": "index.html#attendance-policy",
    "title": "BIOE591: Genomics for Ecology & Conservation",
    "section": "Attendance Policy",
    "text": "Attendance Policy\nPlease do not come to campus if you are sick! I trust you will only miss class when absolutely necessary, and do not need extensive explanations for absences. However, please notify me as soon as practical, so that we can figure appropriate accommodations."
  },
  {
    "objectID": "index.html#inclusivity-statement",
    "href": "index.html#inclusivity-statement",
    "title": "BIOE591: Genomics for Ecology & Conservation",
    "section": "Inclusivity Statement",
    "text": "Inclusivity Statement\nI support an inclusive learning environment where diversity and individual differences are understood, respected, appreciated, and recognized as a source of strength. We expect that students, faculty, administrators and staff at MSU will respect differences and demonstrate diligence in understanding how other peoples’ perspectives, behaviors, and worldviews may be different from their own."
  },
  {
    "objectID": "index.html#syllabus-language-for-students-with-disabilities",
    "href": "index.html#syllabus-language-for-students-with-disabilities",
    "title": "BIOE591: Genomics for Ecology & Conservation",
    "section": "Syllabus Language for Students with Disabilities",
    "text": "Syllabus Language for Students with Disabilities\nIf you are a student with a disability and wish to use your approved accommodations for this course, please contact me during my office hours to discuss. Please have your Accommodation Notification or Blue Card available for verification of accommodations. Accommodations are approved through the Office of Disability Services located in SUB 174. Please see Disability Services for more information."
  },
  {
    "objectID": "cli.html",
    "href": "cli.html",
    "title": "Markdown & Command Line Basics",
    "section": "",
    "text": "For much of the semester we will be executing programs from a command-line interface, or CLI. In scientific computing, a CLI known as the Unix or Linux Shell (sometimes abbreviated *NIX Shell; see if you can figure out why) is most commonly used and a requirement for many scripts and applications. On Mac and Linux operating systems, the CLI is accessed via an application called Terminal, which by default runs a version of the Unix shell called zsh or bash.\nWindows users–though likely already equipped with a CLI called PowerShell or CMD—will need to install a Unix shell emulator, as commands and syntax differs with these interpreters. Unless you have prior knowledge and a strong preference otherwise, I recommend Git for Windows, which comes with a BASH emulator that will work for all lab assignments.\n\n\nTo write code snippets and submit assignments, you will need to have a plain text editor to work with. Plain text files have numerous advantages over writing in (e.g.) a word processing application. First, they are free and open source, something that may become important to you once you lose an academic software license. Second, the files will always remain usable and readable by humans, whereas if Microsoft Word sunsets its proprietary software, .docx files may become useless. Third, they are more or less universally interpretable by other programs (i.e., they are highly portable); this allows you to input data and function arguments to software in automated fashion.\nMac, Linux, and Windows computers all typically come with a preloaded application for this purpose (e.g., textEdit on MacOS). You will likely enjoy a slightly more sophisticated editor aimed at writing code, which typically come with features like syntax highlighting and tab autofill / spellcheck (as well as a suite of AI features and easy version control integration that I will discourage you from using until you know the basics). RStudio provides these features, though as a full-on integrated development environment (or IDE) it is somewhat distracting. In rough order of declining preference, here are my suggestions:\n\nBBEdit (classic; paid and free tiers, though free is more than sufficient)\nSublimeText (works pretty well without a subscription, though you’ll get nagged)\nVSCode (powerful, free, annoying AI integration)\nVim or NeoVim (the hardcore dork option; if you show me you are effectively using this for your assignments, you get one get-out-of-jail free card for homework)\nNotepad++ (the best Windows editor!)\n\nWriting in plain text necessarily means forgoing formatting. Word processing is handled by a lightweight plain-text-to-formatted-text language called Markdown. Markdown is portable, simple, and ubiquitous: it is responsible for formatting this assignment, this course website, my lab website, my lecture slides, GitHub READMEs, Reddit posts, and much more besides. The basic idea is that by surrounding words with a handful of characters, you indicate to an interpreter how text should be formatted. For example, in this sentence I have surrounded the last six words with a pair of two asterices to indicate it should be bold:\n**to indicate it should be bold:**  \nItalics work with a single asterisk at the end of each word, like this:\n*this*:\nHeaders can be rendered with hashtags (# Title, ## Section, ### Subsection). Code can indicated by a pair of accents (`bash.sh`); three in a row on one opens a block of formatted code, which must then be closed by three further down. Depending on the flavor of Markdown, you can indicate syntax highlighting by putting the name of the programming language in brackets after the opening line of accents:\n\nprint(\"BIOE591\")\n\n[1] \"BIOE591\"\n\n\nTables are wonderfully simple. For example, the following text…\n| Student     | Fun Fact             |\n| ----------- | -------------------- |\n| Jason       | Doesn't like to walk |\n| Lizzy       | Has a chubby cat     |\n…renders as:\n\n\n\nStudent\nFun Fact\n\n\n\n\nJason\nDoesn’t like to walk\n\n\nLizzy\nHas a chubby cat\n\n\n\nBlock quotes can be indicated by greater-than signs (&gt;), e.g.\n&gt; Nonethless, Jason is still better at walking than Lizzy's cat.\nbecomes:\n\nNonethless, Jason is still better at walking than Lizzy’s cat.\n\nNumbered lists are equally simple, with the following chunk…\n1. Syllabus\n   -  Stern words\n2. Tease Jason\n   - Relent\n…rendering as:\n\nSyllabus\n\nStern words\n\n\nTease Jason\n\nRelent\n\n\n(Bullet points are handled as you might imagine.)\nA cheat sheet to basic and extended syntax can be found here. The web application JotBird is nice for quickly drafting Markdown documents; you may also be interested in downloading a program that can render Markdown as .pdf or .html files locally, such as Pandoc (recommended). (RMarkdown has this ability as well, though you’ll have to download LaTeX via TinyTeX, MacTeX, or another source.)\n\n\n\nAfter opening Terminal, it’s time to get oriented and learn how to navigate a computer via the CLI. To start, we will figure out where in your file structure you actually are, using the equivalent of the R function getwd():\npwd\nEasily memorized as print working directory, this should indicate you are in your home directory (e.g., /Users/ethanlinck/), a location you can return from wherever you are by typing cd ~ and hitting enter. cd is a fundamental tool of any CLI, allowing you to change directories:\ncd / # switches to the root directory, i.e. the highest level in the hierarchical structure of file storage\ncd .. # move up one level in the file structure hierarchy, i.e. from /Users/ethanlinck/ to /Users/\ncd - # switch to the previous directory\nIt can also use explicit paths. Here is an example with a relative path (from my current home directory, /Users/ethanlinck/):\ncd teaching/genomics/\nThis would navigate to the genomics subdirectory of my teaching directory from my current location. If I am accidentally not in my home directory and there are no such folders where I am, the command will fail. An absolute path helps avoid this risk, though at the cost of flexibility:\ncd /Users/ethanlinck/teaching/genomics/\nUse cd and pwd in combination to navigate around your computer. Note that if you are correctly typing the start of a path, pressing “tab” should autocomplete it, or present options with the same suffix..\nYou can make a directory with the command mkdir and a path (including the name of the new directory):\nmkdir /teaching/genomics/\nMake a new directory entitled test/. We can then create a set of new files to put in test/ for future manipulation using echo, the assignment pipe &gt;, and a filename:\necho \"I love learning\" &gt; ~/test/text1.md; \necho \"I love computers\" &gt; ~/test/text2.md; \necho \"I regret my choices\" &gt; ~/test/.secret;\nmkdir ~/test/sub/ \n(Each line below can be entered individually; the semicolons allow you to copy and past the chunk below without manually entering linebreaks. If you misplace a semicolon or otherwise have a typo, type Ctrl+C to cancel a command. Typing exit closes the current terminal session.)\nNavigate to ~/test/. From a given location—or paired with a path (written in help documents as &lt;path&gt;) you can use the command ls to list the contents of a directory:\nls  ~/test/\nThe command ls -a will reveal “dotfiles”, typically hidden text files that begin with a period and contain information that helps software run. In this class, the dotfile .gitignore will be useful down the line; we may also manipulate .bashrc, which determines settings for the unix shell of a particular user. What are the differences between ls and ls -a when run in test/?\nAt this point you may be wondering where the argument -a came from. The following commands produce documentation (though typing an erroneous argument will also provide a brief example of proper useage)\nman lc #zsh\nlc -h #bash\nCommands can be chained together using a pipe (something you may be familiar with from R). Here I am counting the number of files in a directory using the commands ls and wc, with appropriate arguments:\nls -1 ~/test/ | wc -l # list files in a directory, 1 per line; send output to wc function, count lines\nThe command cat can be used to print (or concatenate) the contents of a file:\ncat ~/test/text1.md\nSimilarly, head can be used to print the first -n lines of a file. We will demonstrate this with a new file and the application of a double pipe (which appends text to new lines):\necho \"test\" &gt; file.md\necho \"test\" &gt;&gt; file.md\necho \"test\" &gt;&gt; file.md\necho \"test\" &gt;&gt; file.md\necho \"test\" &gt;&gt; file.md\necho \"test\" &gt;&gt; file.md\nhead -5 file.md \nThe command mv can be used to move a file to a new location, e.g:\nmv ~/test/text1.md ~/test/sub/text1.md\nThis can also be used to rename files, even within the same directory:\nmv ~/test/sub/text1.md ~/test/sub/text0.md\nAn analog is cp, which copies files:\ncp ~/test/sub/text0.md ~/test/text0.md\nUsing a . in combination with a relative or absolute path will preserve the name of the original file:\ncp ~/test/file.md ~/test/sub/. \nPasting multiple commands in a text document with the suffix .sh creates a shell script, analogous to one written in R or Python. To do so, you need a hashed line called a shebang to start your script to tell your computer to use a particular CLI. You can then add multiple commands, separated by semi-colons:\n#!/usr/bin/env bash\ncd ~/test/; \necho \"lastly\" &gt; newfile.md;\nmv newfile.md ~/test/.;\necho \"file moved\"\nSave this as script.sh in the test/ directory. To do so you may use your new plain text editor, or type nano to access a CLI-based solution available on Mac and Linux machines. (This takes a second to get used to; ask me if you need help. ) Type the command bash script.sh. Does it do what you expect?\nWildcards are characters that match multiple patterns. Most useful for our purposes is *, which will match all files in a given directory, or all\nls * # matches all files in the present directory\nls *.md # matches all files with the suffix \".md\"\nAnother useful wildcard is ?, which matches a single character:\necho \"test\" &gt; tile.md\nls ~/test/?ile.md \nLastly, the command rm removes (deletes) files and directories. For example, rm test/sub/file.md deletes the file test/sub/file.md. Paired with wildcards, you can quickly remove many files in one fell swoop.\nrm ~/test/* # removes all files, but not subdirectories\nrm -r ~/test/ # deletes the directory itself using the \"recursive\" argument -r\n\n\n\n\n\n\nWarningUsing rm with caution\n\n\n\nOne pitfall of becoming a CLI ninja is that you will not get warning messages when you inevitably deploy a powerful command somewhere you don’t intend to. rm paired with a wildcard should be used especially sparingly. What do you think would happen if you navigated to your Desktop and typed the following command?\nrm *\n\n\n\n\n\n\n\n\nNoteHomework 1\n\n\n\nWe will ease into our coding exercises with a brief shell scripting activity. I have created a set of dummy data files that are typical of population genomics—.fastq.gz raw sequencing read files, .fasta assembled sequence data, text files (*.txt), and metadata (*.csv) files. First, download these data using the command curl:\ncurl -L -O https://raw.githubusercontent.com/elinck/genomics_eco_con/main/data/week_1.tar.gz # download a resource at a url\ntar -xzf week_1.tar.gz # this command unzips a \"tarball\"\ncd week_1 # enter the data directory\nUsing the information above and any other resource available to you*, write a single bash script that can perform the following steps:\nWrite a bash script called 01_homework_&lt;your_name&gt;.sh that does the following:\n\nChange into the raw_data directory;\nCreate three subdirectories called:\n\n\nfastq/\nfasta/\nmetadata/\n\n\nMove files into these directories based on file extension:\n\n\n*.fastq.gz to fastq/\n*.fasta to fasta/\n*.csv to metadata/\n\n\nCount how many files are in each new directory and print to the screen.\n\nFor now, you may keep this in your local directory; we’ll work on submitting it as part of next week’s activities.\n* This will generally include AI tools, and as these are an indispensible part of modern programming, I am hesitant to outright ban them for this course. However, it will be in your best interest to attempt to put this script together yourself—from its component parts—as these commands need to become second nature as you navigate the cluster."
  },
  {
    "objectID": "cli.html#plain-text-markdown",
    "href": "cli.html#plain-text-markdown",
    "title": "Markdown & Command Line Basics",
    "section": "",
    "text": "To write code snippets and submit assignments, you will need to have a plain text editor to work with. Plain text files have numerous advantages over writing in (e.g.) a word processing application. First, they are free and open source, something that may become important to you once you lose an academic software license. Second, the files will always remain usable and readable by humans, whereas if Microsoft Word sunsets its proprietary software, .docx files may become useless. Third, they are more or less universally interpretable by other programs (i.e., they are highly portable); this allows you to input data and function arguments to software in automated fashion.\nMac, Linux, and Windows computers all typically come with a preloaded application for this purpose (e.g., textEdit on MacOS). You will likely enjoy a slightly more sophisticated editor aimed at writing code, which typically come with features like syntax highlighting and tab autofill / spellcheck (as well as a suite of AI features and easy version control integration that I will discourage you from using until you know the basics). RStudio provides these features, though as a full-on integrated development environment (or IDE) it is somewhat distracting. In rough order of declining preference, here are my suggestions:\n\nBBEdit (classic; paid and free tiers, though free is more than sufficient)\nSublimeText (works pretty well without a subscription, though you’ll get nagged)\nVSCode (powerful, free, annoying AI integration)\nVim or NeoVim (the hardcore dork option; if you show me you are effectively using this for your assignments, you get one get-out-of-jail free card for homework)\nNotepad++ (the best Windows editor!)\n\nWriting in plain text necessarily means forgoing formatting. Word processing is handled by a lightweight plain-text-to-formatted-text language called Markdown. Markdown is portable, simple, and ubiquitous: it is responsible for formatting this assignment, this course website, my lab website, my lecture slides, GitHub READMEs, Reddit posts, and much more besides. The basic idea is that by surrounding words with a handful of characters, you indicate to an interpreter how text should be formatted. For example, in this sentence I have surrounded the last six words with a pair of two asterices to indicate it should be bold:\n**to indicate it should be bold:**  \nItalics work with a single asterisk at the end of each word, like this:\n*this*:\nHeaders can be rendered with hashtags (# Title, ## Section, ### Subsection). Code can indicated by a pair of accents (`bash.sh`); three in a row on one opens a block of formatted code, which must then be closed by three further down. Depending on the flavor of Markdown, you can indicate syntax highlighting by putting the name of the programming language in brackets after the opening line of accents:\n\nprint(\"BIOE591\")\n\n[1] \"BIOE591\"\n\n\nTables are wonderfully simple. For example, the following text…\n| Student     | Fun Fact             |\n| ----------- | -------------------- |\n| Jason       | Doesn't like to walk |\n| Lizzy       | Has a chubby cat     |\n…renders as:\n\n\n\nStudent\nFun Fact\n\n\n\n\nJason\nDoesn’t like to walk\n\n\nLizzy\nHas a chubby cat\n\n\n\nBlock quotes can be indicated by greater-than signs (&gt;), e.g.\n&gt; Nonethless, Jason is still better at walking than Lizzy's cat.\nbecomes:\n\nNonethless, Jason is still better at walking than Lizzy’s cat.\n\nNumbered lists are equally simple, with the following chunk…\n1. Syllabus\n   -  Stern words\n2. Tease Jason\n   - Relent\n…rendering as:\n\nSyllabus\n\nStern words\n\n\nTease Jason\n\nRelent\n\n\n(Bullet points are handled as you might imagine.)\nA cheat sheet to basic and extended syntax can be found here. The web application JotBird is nice for quickly drafting Markdown documents; you may also be interested in downloading a program that can render Markdown as .pdf or .html files locally, such as Pandoc (recommended). (RMarkdown has this ability as well, though you’ll have to download LaTeX via TinyTeX, MacTeX, or another source.)"
  },
  {
    "objectID": "cli.html#directory-structure",
    "href": "cli.html#directory-structure",
    "title": "Markdown & Command Line Basics",
    "section": "",
    "text": "After opening Terminal, it’s time to get oriented and learn how to navigate a computer via the CLI. To start, we will figure out where in your file structure you actually are, using the equivalent of the R function getwd():\npwd\nEasily memorized as print working directory, this should indicate you are in your home directory (e.g., /Users/ethanlinck/), a location you can return from wherever you are by typing cd ~ and hitting enter. cd is a fundamental tool of any CLI, allowing you to change directories:\ncd / # switches to the root directory, i.e. the highest level in the hierarchical structure of file storage\ncd .. # move up one level in the file structure hierarchy, i.e. from /Users/ethanlinck/ to /Users/\ncd - # switch to the previous directory\nIt can also use explicit paths. Here is an example with a relative path (from my current home directory, /Users/ethanlinck/):\ncd teaching/genomics/\nThis would navigate to the genomics subdirectory of my teaching directory from my current location. If I am accidentally not in my home directory and there are no such folders where I am, the command will fail. An absolute path helps avoid this risk, though at the cost of flexibility:\ncd /Users/ethanlinck/teaching/genomics/\nUse cd and pwd in combination to navigate around your computer. Note that if you are correctly typing the start of a path, pressing “tab” should autocomplete it, or present options with the same suffix..\nYou can make a directory with the command mkdir and a path (including the name of the new directory):\nmkdir /teaching/genomics/\nMake a new directory entitled test/. We can then create a set of new files to put in test/ for future manipulation using echo, the assignment pipe &gt;, and a filename:\necho \"I love learning\" &gt; ~/test/text1.md; \necho \"I love computers\" &gt; ~/test/text2.md; \necho \"I regret my choices\" &gt; ~/test/.secret;\nmkdir ~/test/sub/ \n(Each line below can be entered individually; the semicolons allow you to copy and past the chunk below without manually entering linebreaks. If you misplace a semicolon or otherwise have a typo, type Ctrl+C to cancel a command. Typing exit closes the current terminal session.)\nNavigate to ~/test/. From a given location—or paired with a path (written in help documents as &lt;path&gt;) you can use the command ls to list the contents of a directory:\nls  ~/test/\nThe command ls -a will reveal “dotfiles”, typically hidden text files that begin with a period and contain information that helps software run. In this class, the dotfile .gitignore will be useful down the line; we may also manipulate .bashrc, which determines settings for the unix shell of a particular user. What are the differences between ls and ls -a when run in test/?\nAt this point you may be wondering where the argument -a came from. The following commands produce documentation (though typing an erroneous argument will also provide a brief example of proper useage)\nman lc #zsh\nlc -h #bash\nCommands can be chained together using a pipe (something you may be familiar with from R). Here I am counting the number of files in a directory using the commands ls and wc, with appropriate arguments:\nls -1 ~/test/ | wc -l # list files in a directory, 1 per line; send output to wc function, count lines\nThe command cat can be used to print (or concatenate) the contents of a file:\ncat ~/test/text1.md\nSimilarly, head can be used to print the first -n lines of a file. We will demonstrate this with a new file and the application of a double pipe (which appends text to new lines):\necho \"test\" &gt; file.md\necho \"test\" &gt;&gt; file.md\necho \"test\" &gt;&gt; file.md\necho \"test\" &gt;&gt; file.md\necho \"test\" &gt;&gt; file.md\necho \"test\" &gt;&gt; file.md\nhead -5 file.md \nThe command mv can be used to move a file to a new location, e.g:\nmv ~/test/text1.md ~/test/sub/text1.md\nThis can also be used to rename files, even within the same directory:\nmv ~/test/sub/text1.md ~/test/sub/text0.md\nAn analog is cp, which copies files:\ncp ~/test/sub/text0.md ~/test/text0.md\nUsing a . in combination with a relative or absolute path will preserve the name of the original file:\ncp ~/test/file.md ~/test/sub/. \nPasting multiple commands in a text document with the suffix .sh creates a shell script, analogous to one written in R or Python. To do so, you need a hashed line called a shebang to start your script to tell your computer to use a particular CLI. You can then add multiple commands, separated by semi-colons:\n#!/usr/bin/env bash\ncd ~/test/; \necho \"lastly\" &gt; newfile.md;\nmv newfile.md ~/test/.;\necho \"file moved\"\nSave this as script.sh in the test/ directory. To do so you may use your new plain text editor, or type nano to access a CLI-based solution available on Mac and Linux machines. (This takes a second to get used to; ask me if you need help. ) Type the command bash script.sh. Does it do what you expect?\nWildcards are characters that match multiple patterns. Most useful for our purposes is *, which will match all files in a given directory, or all\nls * # matches all files in the present directory\nls *.md # matches all files with the suffix \".md\"\nAnother useful wildcard is ?, which matches a single character:\necho \"test\" &gt; tile.md\nls ~/test/?ile.md \nLastly, the command rm removes (deletes) files and directories. For example, rm test/sub/file.md deletes the file test/sub/file.md. Paired with wildcards, you can quickly remove many files in one fell swoop.\nrm ~/test/* # removes all files, but not subdirectories\nrm -r ~/test/ # deletes the directory itself using the \"recursive\" argument -r\n\n\n\n\n\n\nWarningUsing rm with caution\n\n\n\nOne pitfall of becoming a CLI ninja is that you will not get warning messages when you inevitably deploy a powerful command somewhere you don’t intend to. rm paired with a wildcard should be used especially sparingly. What do you think would happen if you navigated to your Desktop and typed the following command?\nrm *\n\n\n\n\n\n\n\n\nNoteHomework 1\n\n\n\nWe will ease into our coding exercises with a brief shell scripting activity. I have created a set of dummy data files that are typical of population genomics—.fastq.gz raw sequencing read files, .fasta assembled sequence data, text files (*.txt), and metadata (*.csv) files. First, download these data using the command curl:\ncurl -L -O https://raw.githubusercontent.com/elinck/genomics_eco_con/main/data/week_1.tar.gz # download a resource at a url\ntar -xzf week_1.tar.gz # this command unzips a \"tarball\"\ncd week_1 # enter the data directory\nUsing the information above and any other resource available to you*, write a single bash script that can perform the following steps:\nWrite a bash script called 01_homework_&lt;your_name&gt;.sh that does the following:\n\nChange into the raw_data directory;\nCreate three subdirectories called:\n\n\nfastq/\nfasta/\nmetadata/\n\n\nMove files into these directories based on file extension:\n\n\n*.fastq.gz to fastq/\n*.fasta to fasta/\n*.csv to metadata/\n\n\nCount how many files are in each new directory and print to the screen.\n\nFor now, you may keep this in your local directory; we’ll work on submitting it as part of next week’s activities.\n* This will generally include AI tools, and as these are an indispensible part of modern programming, I am hesitant to outright ban them for this course. However, it will be in your best interest to attempt to put this script together yourself—from its component parts—as these commands need to become second nature as you navigate the cluster."
  },
  {
    "objectID": "git.html",
    "href": "git.html",
    "title": "Version Control with Git and GitHub",
    "section": "",
    "text": "Our discussion of reproducibility and its importance to scientific programming and bioinformatics touched on the challenge of keeping track of the “final” version of an analysis in the face of data exploration and troubleshooting. Consider your own history of writing code for data manipulation and analysis. What strategies have you used to keep track of multiple versions of an analysis? Common approaches include saving multiple versions of files with different names, repeatedly pasting the same chunk of code with slight modifications in the same script, and closed-source, cloud-based file storage solutions like Dropbox and Google Drive. The latter provide some degree of version control, i.e. snapshots of the version of a file at a particular time point. But they suffer from many of the disadvantages of proprietary software, and are not optimized for writing computer code, plain text files, or working collaboratively.\nSoftware developers have created a powerful solution to this common dilemma, with clear benefits to conducting reproducible research in ecology, evolution, and related fields. Pairing a version control system (VCS; local software) with online hosting sites (to distribute and back up file versions) allows continuous, collaborative editing across dispersed contributers, annotation of different versions of files, and an easy way to share open-source scientific software and documents for review and to aid other researchers. Though the learning curve can be steep, learning to effectively use a VCS and online repository is a minimum standard for conducting ethical, transparent computational research—especially when working with genomic data. It also will open the door to using myriad task-specific software packages written by the vibrant scientific computing community. In this class, we will learn the basics of Git and the online hosting service GitHub, though the principles discussed apply to other platforms.\n\n\nIf you have not yet worked with Git and GitHub—or have not yet downloaded Git for Windows to obtain a bash emulator—you will likely need to install the appropriate version of Git for your operating system. To do so, follow the instructions on this website. Once you have completed the installation, open your terminal and type the following command:\ngit\nAssuming the output is a lengthy message of command options, you have successfully installed Git.\n\n\n\nAfter installing Git, you’ll need a GitHub account to link to it (assuming you don’t already have one). To do so, click “Sign Up” on the website; detailed instructions are available here. For better or worse, you will also have to activate two-factor authentication (2FA) in some way. Make sure you verify your email address.\nNext, you’ll need to tell Git who you are, using the exact user.name and user.email previously provided to GitHub:\ngit config --global user.name \"Jean-Baptiste Lamarck\"\ngit config --global user.email \"lamarck@mnhn.fr\"\nVerify your information has been entered correctly with the following command:\ngit config --global --list\nAfter this, you’ll need to cache your credentials to avoid being prompted to enter a username and password everytime you interact with a remote repository. This is one of the trickier steps to getting Git and GitHub playing nicely together, and I anticipate some of you will have issues.\n\nTo start, navigate to Settings → Developer Settings.\nClick “Tokens (classic)” under “Personal access tokens”.\nClick “Generate new token” and select “Generate new token (classic)”.\nIn the “Note” field, type something informative, avoiding spaces (e.g., “bioe591-token”).\nSelect an expiration date of June 2026 or later.\nUnder “Select scopes”, click the main “repo” box, and then “Generate token”.\nIMMEDIATELY save the text string that appears to a single line of a text editor—this will quickly disappear, and you’ll need to start over.\n\nOnce you’ve created a PAT, you’ll want to save it on your computer’s credentialing system. The exact steps will differ by operating system.\nMac OS: Type the following command:\ngit config --global credential.helper osxkeychain\nNext, type a command that requires a link between Git and GitHub:\ngit ls-remote https://github.com/USERNAME/this-repo-does-not-exist\nYou should be prompted to enter your username and password. When the “password” prompt appears in the terminal, paste the entire PAT string from your plain text document into the field. You will NOT see anything appear; this is normal. Hit enter; the command will then indicate the repository does not exist (this is expected). You should now be all set to use Git and GitHub without repeated authentication requests.\nWindows: Type the following command:\ngit config --global --get credential.helper\nLikely output will be manager. If this does not appear, configure it explicitly:\ngit config --global credential.helper manager\nYou will then need type a command that requires a link between Git and GitHub:\ngit ls-remote https://github.com/USERNAME/this-repo-does-not-exist\nAs with Mac OS, this will prompt you to enter your username, then your password; you may paste the PAT string in the password field and hit enter. It will save to your computer’s credential manager automatically.\nLinux: Enter the following commands:\ngit config --global credential.helper store\nchmod 600 ~/.git-credentials # ensure you have appropriate permissions to write to this file\nAs with the other operating systems, this will store your PAT after your are prompted to enter it:\ngit ls-remote https://github.com/USERNAME/this-repo-does-not-exist\n(Unlike the other OS, it will be in an easily-found dotfile: ~/.git-credentials. We will use a separate authentication protocol when working from the cluster, to be introduced later.)\n\n\n\nWith a bit of luck, the previous steps should have been relatively painless and you should now be ready to begin your first Git and GitHub workflow. To start, navigate to GitHub and create a repository (via the “Repositories” tab and then the “New” button). Name your repository something associated with this class and your initials, or an otherwise informative and unique combination. You may also enter a brief description of the contents of the repository in the provided bar. Leave all other options blank for now. The new repository should now open as a stand-alone webpage. Under the green “&lt;&gt; Code” button, copy the link under the HTTPS tag. Open your terminal, navigate to a directory where you keep homework or research projects, and make a new directory for this class:\nmkdir bioe591_work\nYou next want to initialize this as Git repository:\ngit init\nThis command will then create a new dotfile (i.e., a hidden file, technically a directory) with the name of .git. Its contents can be made visible with the following command, though you can ignore them now and always:\nls .git\nYou will then link your local repository to its online counterpart. In the command below, origin is an alias for the URL that Git is assigning to be a remote copy of your local work. (You’ll want to replace the link below with the link to your new GitHub repository, of course.)\ngit remote add origin https://github.com/USERNAME/class-repo\nOnce this is done, it’s time to test out a sample workflow. We can start by creating a file called README.md, which by default will be displayed on as the landing page for your GitHub repository, complete with Markdown formatting. For the purposes of the tutorial, we can create this with a single line of code:\necho \"# BIOE591 Coursework Repository\" &gt; README.md\n(However, you should feel free to edit this as you see fit, either with nano or another text editor of your choice—for now, the contents don’t matter.)\nNext, we’ll create a special dotfile called .gitignore. This is not strictly necessary, but can be helpful if you want to avoid adding particular files to your remote repository. Consider a scenario in which you have a folder filled with sequencing reads (raw_reads/). These data are large and cumbersome, and you won’t want to hsot them on GitHub itself. Add them to your .gitignore with the following command:\necho \"raw_reads/\" &gt; .gitignore\nA second line can be added to the same file using &gt;&gt;. On Mac OS systems, for example, a pesky dotfile called .DS_Store is often present, and never needed in a repository. Just to be sure (and as an exercise regardless of your operating system), let’s add it as well, and then print the contents of the file to the screen:\necho \". DS_Store\" &gt;&gt; .gitignore\ncat .gitignore\nWe are now ready to update our remote repository. To do so, we will take a series of steps that 1) tell Git which files to track (git add); 2) move a snapshot of the version of the files from our current working directory to a staging area (git commit); 3) upload these file version to GitHub (git push). Let’s work through these one by one. To begin, we need to begin tracking the contents of the repository. The quickest way to do this is to type the following command, where . indicates the entire contents of the directory:\ngit add .\nThis is exactly equivalent to typing git add README.md followed by git add .gitignore, i.e. manually tracking both files (a move which can sometimes be useful). By default, git add will only impact files with changed contents (including brand new files). Next, you need move these tracked files to a staging area, where you will add a short note (using the -m flag) describing the reason for any revisions, deletions, or additions:\ngit commit -m \"add first files\" \nAt this point it is time for a brief digression. We have already discussed the difference between your working directory, an abstracted “staging area”, and your remote repository. For the vast majority of work you are likely to do, waiting until code is ostensible bug-free to add, commit, and push changes within your working directory to a remote repository is likely to be best practice. For more complex projects, however, it can be useful to have a local copy of your code to modify and experiment with while keeping the last working version in safe condition. Git’s solution to this is called branching. By default, the first version of a particular project is assigned to a branch called main, which is initiated with your first commit. You can verify this by typing the following command:\ngit branch\nA suite of commands are associated with creating, switching between, and ultimately merging work in different branches. These are beyond the scope of our introduction, but if you are interested in a deeper understanding, I recommend visiting Git’s tutorial on the topic. For now, it will suffice to know that your work in this class will always be in main.\n\n\n\nA flow chart of fundamental Git commands and their relationship to working directories and repositories, courtesy of Hirdyansh Pandey on LinkedIn\n\n\nWe now return to our workflow. Recall that we have “committed” a set of files (README.md and .gitignore) to a staging area, with a message describing our work. We are now ready to add these files to our online repository:\ngit push -u origin main\nHere, the command -u sets “upstream tracking”—a fancy way of saying your local changes will always get sent to the online repository when you push, and not anywhere else. (Practically, this means you can type git push without the rest of the command whenever you work in this repository from now on.) You can now navigate the the url for your remote repository. Unless something has gone wrong, you should see it has been updated to reflect the tracked, commited contents of your local directory. Congratulations! You’ve now effectively used Git and GitHub. Most of the time, this is all there is to it. However, it will be helpful to address two other common uses of version control before concluding. First, let’s learn how to revert to an earlier version of a particular project. To do so, we’ll edit our README, commit it, and push it again:\necho \"questionable edit\" &gt;&gt; README.md\ngit add README.md\ngit commit -m \"edit I will not regret \"\ngit push\nYour GitHub repository should now show a modified README.md file. Unfortunately, this tweak breaks your data analysis pipeline, and you decide you need to return to the script you were working with earlier. To do so, click the link that reads “2 Commits” below the green “Code” button. Here, you will see your full commit history: two file versions, each with a unique code in a format similar to b38e27a. (This same history can be shown locally with the command git log --oneline.) The command git checkout can be paired with a commit code to instantly revert to that snapshot of your work:\ngit checkout c66e60b -- .\n(The command -- is a delimiter telling Git that everything afterwards should not be interpreted as a command; the . is a wildcard indicating that you wish to change the entire contents of the directory.).\nTyping git status should show that you now have changes waiting to be committed. Add, commit, and push this reversion, then confirm that your GitHub repository has been updated appropriately.\nOur final Git lesson involves deliberately breaking something, which we do with the hope that it will help you troubleshoot accidental errors in the future. Back on your GitHub repository, navigate to README.md and click the edit button (a sketch of a pencil on the righthand side of the document when seen from the landing page). Doing so opens a text editor. In the contents of the file, add a line reading “github edit” or similar. You will be prompted to commit this edit—go ahead and do so.\nNext, return to your working directory. Using nano or another text editor, edit your local copy of README.md, adding the line “local edit”. Save, add, and commit. Now, attempt to push your work to GitHub (git push). You should see an error message that reads Updates were rejected because the remote contains work that you do not have locally. This is usually caused by another repository pushing to the same ref. You may want to first integrate the remote changes (e.g., 'git pull ...') before pushing again.\nIn general, following the advice provided by error messages is solid practice. Type git pull. The following text should appear:\nAuto-merging README.md  \nCONFLICT (content): Merge conflict in README.md  \nAutomatic merge failed; fix conflicts and then commit the result.  \nThis is a common sticking point and can be one of the most difficult aspects of working with a VCS for beginners. Luckily, the solution is relatively simple. Using nano or another editor, open the README.md file. You’ll see text similar to the following:\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nlocal edit\n=======\ngithub edit\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/main\nThe arrows (&gt;&gt;&gt;) and equals signs (===) have been added by Git to highlight a conflict between the two versions. All the software is doing is prompting you to choose between the two file versions (or combine them). Edit as you see fit—which typically involves removing those delimiters—add, commit, and push. Crisis averted!\nFinally, it can be useful to visualize exactly how your working directory and remote repository have changed and merged over time. To do so, use the following command:\ngit log --oneline --graph\n\n\n\nYou should now feel comfortable—well, at least understand the purpose, in the abstract—of the following commands:\ngit status\ngit add\ngit commit\ngit pull\ngit push\ngit log --oneline --graph\ngit checkout -b\nWith time, these should become second nature, and help you develop\n\n\n\n\n\n\nNoteHomework 2\n\n\n\nToday’s homework is fairly simple, and intended to reinforce the skills you have just built:\n\nIn the repository you made for this class, create a new subdirectory called homework/. Move your bash script from last week (01_homework_&lt;your_name&gt;.sh) inside it.\n\nEdit your README.md file to describe the overall structure of your repository and its subdirectories. This file will be my guide to finding to your homework assignments, so the more informative, the better!\nAdd, commit, and push the script to GitHub.\nReturn to 01_homework_&lt;your_name&gt;.sh. Add a line of bash code to the end of the script that prints “DONE!” or something similar to the screen after counting all files in the directory. Add, commit, and push this new version to GitHub. (I will be checking the commit log on your account, so make sure you add a message signaling this change.)"
  },
  {
    "objectID": "git.html#installation",
    "href": "git.html#installation",
    "title": "Version Control with Git and GitHub",
    "section": "",
    "text": "If you have not yet worked with Git and GitHub—or have not yet downloaded Git for Windows to obtain a bash emulator—you will likely need to install the appropriate version of Git for your operating system. To do so, follow the instructions on this website. Once you have completed the installation, open your terminal and type the following command:\ngit\nAssuming the output is a lengthy message of command options, you have successfully installed Git."
  },
  {
    "objectID": "git.html#linking-git-and-github",
    "href": "git.html#linking-git-and-github",
    "title": "Version Control with Git and GitHub",
    "section": "",
    "text": "After installing Git, you’ll need a GitHub account to link to it (assuming you don’t already have one). To do so, click “Sign Up” on the website; detailed instructions are available here. For better or worse, you will also have to activate two-factor authentication (2FA) in some way. Make sure you verify your email address.\nNext, you’ll need to tell Git who you are, using the exact user.name and user.email previously provided to GitHub:\ngit config --global user.name \"Jean-Baptiste Lamarck\"\ngit config --global user.email \"lamarck@mnhn.fr\"\nVerify your information has been entered correctly with the following command:\ngit config --global --list\nAfter this, you’ll need to cache your credentials to avoid being prompted to enter a username and password everytime you interact with a remote repository. This is one of the trickier steps to getting Git and GitHub playing nicely together, and I anticipate some of you will have issues.\n\nTo start, navigate to Settings → Developer Settings.\nClick “Tokens (classic)” under “Personal access tokens”.\nClick “Generate new token” and select “Generate new token (classic)”.\nIn the “Note” field, type something informative, avoiding spaces (e.g., “bioe591-token”).\nSelect an expiration date of June 2026 or later.\nUnder “Select scopes”, click the main “repo” box, and then “Generate token”.\nIMMEDIATELY save the text string that appears to a single line of a text editor—this will quickly disappear, and you’ll need to start over.\n\nOnce you’ve created a PAT, you’ll want to save it on your computer’s credentialing system. The exact steps will differ by operating system.\nMac OS: Type the following command:\ngit config --global credential.helper osxkeychain\nNext, type a command that requires a link between Git and GitHub:\ngit ls-remote https://github.com/USERNAME/this-repo-does-not-exist\nYou should be prompted to enter your username and password. When the “password” prompt appears in the terminal, paste the entire PAT string from your plain text document into the field. You will NOT see anything appear; this is normal. Hit enter; the command will then indicate the repository does not exist (this is expected). You should now be all set to use Git and GitHub without repeated authentication requests.\nWindows: Type the following command:\ngit config --global --get credential.helper\nLikely output will be manager. If this does not appear, configure it explicitly:\ngit config --global credential.helper manager\nYou will then need type a command that requires a link between Git and GitHub:\ngit ls-remote https://github.com/USERNAME/this-repo-does-not-exist\nAs with Mac OS, this will prompt you to enter your username, then your password; you may paste the PAT string in the password field and hit enter. It will save to your computer’s credential manager automatically.\nLinux: Enter the following commands:\ngit config --global credential.helper store\nchmod 600 ~/.git-credentials # ensure you have appropriate permissions to write to this file\nAs with the other operating systems, this will store your PAT after your are prompted to enter it:\ngit ls-remote https://github.com/USERNAME/this-repo-does-not-exist\n(Unlike the other OS, it will be in an easily-found dotfile: ~/.git-credentials. We will use a separate authentication protocol when working from the cluster, to be introduced later.)"
  },
  {
    "objectID": "git.html#git-and-github-basics",
    "href": "git.html#git-and-github-basics",
    "title": "Version Control with Git and GitHub",
    "section": "",
    "text": "With a bit of luck, the previous steps should have been relatively painless and you should now be ready to begin your first Git and GitHub workflow. To start, navigate to GitHub and create a repository (via the “Repositories” tab and then the “New” button). Name your repository something associated with this class and your initials, or an otherwise informative and unique combination. You may also enter a brief description of the contents of the repository in the provided bar. Leave all other options blank for now. The new repository should now open as a stand-alone webpage. Under the green “&lt;&gt; Code” button, copy the link under the HTTPS tag. Open your terminal, navigate to a directory where you keep homework or research projects, and make a new directory for this class:\nmkdir bioe591_work\nYou next want to initialize this as Git repository:\ngit init\nThis command will then create a new dotfile (i.e., a hidden file, technically a directory) with the name of .git. Its contents can be made visible with the following command, though you can ignore them now and always:\nls .git\nYou will then link your local repository to its online counterpart. In the command below, origin is an alias for the URL that Git is assigning to be a remote copy of your local work. (You’ll want to replace the link below with the link to your new GitHub repository, of course.)\ngit remote add origin https://github.com/USERNAME/class-repo\nOnce this is done, it’s time to test out a sample workflow. We can start by creating a file called README.md, which by default will be displayed on as the landing page for your GitHub repository, complete with Markdown formatting. For the purposes of the tutorial, we can create this with a single line of code:\necho \"# BIOE591 Coursework Repository\" &gt; README.md\n(However, you should feel free to edit this as you see fit, either with nano or another text editor of your choice—for now, the contents don’t matter.)\nNext, we’ll create a special dotfile called .gitignore. This is not strictly necessary, but can be helpful if you want to avoid adding particular files to your remote repository. Consider a scenario in which you have a folder filled with sequencing reads (raw_reads/). These data are large and cumbersome, and you won’t want to hsot them on GitHub itself. Add them to your .gitignore with the following command:\necho \"raw_reads/\" &gt; .gitignore\nA second line can be added to the same file using &gt;&gt;. On Mac OS systems, for example, a pesky dotfile called .DS_Store is often present, and never needed in a repository. Just to be sure (and as an exercise regardless of your operating system), let’s add it as well, and then print the contents of the file to the screen:\necho \". DS_Store\" &gt;&gt; .gitignore\ncat .gitignore\nWe are now ready to update our remote repository. To do so, we will take a series of steps that 1) tell Git which files to track (git add); 2) move a snapshot of the version of the files from our current working directory to a staging area (git commit); 3) upload these file version to GitHub (git push). Let’s work through these one by one. To begin, we need to begin tracking the contents of the repository. The quickest way to do this is to type the following command, where . indicates the entire contents of the directory:\ngit add .\nThis is exactly equivalent to typing git add README.md followed by git add .gitignore, i.e. manually tracking both files (a move which can sometimes be useful). By default, git add will only impact files with changed contents (including brand new files). Next, you need move these tracked files to a staging area, where you will add a short note (using the -m flag) describing the reason for any revisions, deletions, or additions:\ngit commit -m \"add first files\" \nAt this point it is time for a brief digression. We have already discussed the difference between your working directory, an abstracted “staging area”, and your remote repository. For the vast majority of work you are likely to do, waiting until code is ostensible bug-free to add, commit, and push changes within your working directory to a remote repository is likely to be best practice. For more complex projects, however, it can be useful to have a local copy of your code to modify and experiment with while keeping the last working version in safe condition. Git’s solution to this is called branching. By default, the first version of a particular project is assigned to a branch called main, which is initiated with your first commit. You can verify this by typing the following command:\ngit branch\nA suite of commands are associated with creating, switching between, and ultimately merging work in different branches. These are beyond the scope of our introduction, but if you are interested in a deeper understanding, I recommend visiting Git’s tutorial on the topic. For now, it will suffice to know that your work in this class will always be in main.\n\n\n\nA flow chart of fundamental Git commands and their relationship to working directories and repositories, courtesy of Hirdyansh Pandey on LinkedIn\n\n\nWe now return to our workflow. Recall that we have “committed” a set of files (README.md and .gitignore) to a staging area, with a message describing our work. We are now ready to add these files to our online repository:\ngit push -u origin main\nHere, the command -u sets “upstream tracking”—a fancy way of saying your local changes will always get sent to the online repository when you push, and not anywhere else. (Practically, this means you can type git push without the rest of the command whenever you work in this repository from now on.) You can now navigate the the url for your remote repository. Unless something has gone wrong, you should see it has been updated to reflect the tracked, commited contents of your local directory. Congratulations! You’ve now effectively used Git and GitHub. Most of the time, this is all there is to it. However, it will be helpful to address two other common uses of version control before concluding. First, let’s learn how to revert to an earlier version of a particular project. To do so, we’ll edit our README, commit it, and push it again:\necho \"questionable edit\" &gt;&gt; README.md\ngit add README.md\ngit commit -m \"edit I will not regret \"\ngit push\nYour GitHub repository should now show a modified README.md file. Unfortunately, this tweak breaks your data analysis pipeline, and you decide you need to return to the script you were working with earlier. To do so, click the link that reads “2 Commits” below the green “Code” button. Here, you will see your full commit history: two file versions, each with a unique code in a format similar to b38e27a. (This same history can be shown locally with the command git log --oneline.) The command git checkout can be paired with a commit code to instantly revert to that snapshot of your work:\ngit checkout c66e60b -- .\n(The command -- is a delimiter telling Git that everything afterwards should not be interpreted as a command; the . is a wildcard indicating that you wish to change the entire contents of the directory.).\nTyping git status should show that you now have changes waiting to be committed. Add, commit, and push this reversion, then confirm that your GitHub repository has been updated appropriately.\nOur final Git lesson involves deliberately breaking something, which we do with the hope that it will help you troubleshoot accidental errors in the future. Back on your GitHub repository, navigate to README.md and click the edit button (a sketch of a pencil on the righthand side of the document when seen from the landing page). Doing so opens a text editor. In the contents of the file, add a line reading “github edit” or similar. You will be prompted to commit this edit—go ahead and do so.\nNext, return to your working directory. Using nano or another text editor, edit your local copy of README.md, adding the line “local edit”. Save, add, and commit. Now, attempt to push your work to GitHub (git push). You should see an error message that reads Updates were rejected because the remote contains work that you do not have locally. This is usually caused by another repository pushing to the same ref. You may want to first integrate the remote changes (e.g., 'git pull ...') before pushing again.\nIn general, following the advice provided by error messages is solid practice. Type git pull. The following text should appear:\nAuto-merging README.md  \nCONFLICT (content): Merge conflict in README.md  \nAutomatic merge failed; fix conflicts and then commit the result.  \nThis is a common sticking point and can be one of the most difficult aspects of working with a VCS for beginners. Luckily, the solution is relatively simple. Using nano or another editor, open the README.md file. You’ll see text similar to the following:\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nlocal edit\n=======\ngithub edit\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/main\nThe arrows (&gt;&gt;&gt;) and equals signs (===) have been added by Git to highlight a conflict between the two versions. All the software is doing is prompting you to choose between the two file versions (or combine them). Edit as you see fit—which typically involves removing those delimiters—add, commit, and push. Crisis averted!\nFinally, it can be useful to visualize exactly how your working directory and remote repository have changed and merged over time. To do so, use the following command:\ngit log --oneline --graph"
  },
  {
    "objectID": "git.html#summary",
    "href": "git.html#summary",
    "title": "Version Control with Git and GitHub",
    "section": "",
    "text": "You should now feel comfortable—well, at least understand the purpose, in the abstract—of the following commands:\ngit status\ngit add\ngit commit\ngit pull\ngit push\ngit log --oneline --graph\ngit checkout -b\nWith time, these should become second nature, and help you develop\n\n\n\n\n\n\nNoteHomework 2\n\n\n\nToday’s homework is fairly simple, and intended to reinforce the skills you have just built:\n\nIn the repository you made for this class, create a new subdirectory called homework/. Move your bash script from last week (01_homework_&lt;your_name&gt;.sh) inside it.\n\nEdit your README.md file to describe the overall structure of your repository and its subdirectories. This file will be my guide to finding to your homework assignments, so the more informative, the better!\nAdd, commit, and push the script to GitHub.\nReturn to 01_homework_&lt;your_name&gt;.sh. Add a line of bash code to the end of the script that prints “DONE!” or something similar to the screen after counting all files in the directory. Add, commit, and push this new version to GitHub. (I will be checking the commit log on your account, so make sure you add a message signaling this change.)"
  },
  {
    "objectID": "assessment.html",
    "href": "assessment.html",
    "title": "BIOE591: Preliminary Assessment",
    "section": "",
    "text": "This course is targeted at graduate students who plan to work with high-throughput, short-read DNA sequence data. I therefore assume a solid background in genetics as relates to your chosen field. I further assume some proficiency in using the computer, and prior exposure (even if limited) to the basics of scientific programming in R or Python. To help me adjust my instruction to your needs and current skillset, I would like you to answer the following questions in a separate document and email me the answers. (This will not be graded, but will count towards your participation grade.)\n\n\n\nWhat is the Central Dogma?\nWhat is DNA? What are the four nucleotides?\nWhat is RNA? What are the four ribonucleotides?\nWhere do you find DNA in an organisms?\nWhat is an allele, and what is an allele frequency? How would you calculate an allele frequency with DNA sequence data?\nWhat is a genetic marker?\nWhere does genetic variation come from?\nWhat forces impact patterns of genetic variation?\nWhat is a genome?\nHow big is a mammal genome (to an order of magnitude)?\nWhat is ploidy? Are humans diploid, haploid, or tetraploid?\nWhat is recombination?\nWhat is linkage disequilibrium?\nWhat are three types of mutations?\nWhat is population genetic stucture / population subdivision?\n\n\n\n\n\nWhat kind of computer do you have, and what operating system does it run?\nWhat is memory? How much memory does your computer have?\nWhat is storage? How much storage space does your computer have?\nCreate a folder (or directory) for this course and provide its path below.\nPick a recent research project, class assignment, or work task that required you to create a directory. How did you structure its contents?\nHave you ever used the command line?\nWhat is a computing cluster, and have you ever used one?\nWhat programming languages have you used, if any?\nWhat is a package (or library)?\nHave you ever written a function?\nWhat is version control?\nHave you used Git or GitHub?\nWhat does it mean for an analysis to be reproducible?\nHave you ever archived data?\nWhat is open source software?\n\n\n\n\n\nWhat are you hoping to get out of this class?\nDo you have your own dataset, or will you be working with an example?\nWhat kind of questions do you want to address with data?\nWhat are you worried about in this class, if anything?\nIs there anything else I should know to help you have a good semester?"
  },
  {
    "objectID": "assessment.html#genetics",
    "href": "assessment.html#genetics",
    "title": "BIOE591: Preliminary Assessment",
    "section": "",
    "text": "What is the Central Dogma?\nWhat is DNA? What are the four nucleotides?\nWhat is RNA? What are the four ribonucleotides?\nWhere do you find DNA in an organisms?\nWhat is an allele, and what is an allele frequency? How would you calculate an allele frequency with DNA sequence data?\nWhat is a genetic marker?\nWhere does genetic variation come from?\nWhat forces impact patterns of genetic variation?\nWhat is a genome?\nHow big is a mammal genome (to an order of magnitude)?\nWhat is ploidy? Are humans diploid, haploid, or tetraploid?\nWhat is recombination?\nWhat is linkage disequilibrium?\nWhat are three types of mutations?\nWhat is population genetic stucture / population subdivision?"
  },
  {
    "objectID": "assessment.html#computer-skills",
    "href": "assessment.html#computer-skills",
    "title": "BIOE591: Preliminary Assessment",
    "section": "",
    "text": "What kind of computer do you have, and what operating system does it run?\nWhat is memory? How much memory does your computer have?\nWhat is storage? How much storage space does your computer have?\nCreate a folder (or directory) for this course and provide its path below.\nPick a recent research project, class assignment, or work task that required you to create a directory. How did you structure its contents?\nHave you ever used the command line?\nWhat is a computing cluster, and have you ever used one?\nWhat programming languages have you used, if any?\nWhat is a package (or library)?\nHave you ever written a function?\nWhat is version control?\nHave you used Git or GitHub?\nWhat does it mean for an analysis to be reproducible?\nHave you ever archived data?\nWhat is open source software?"
  },
  {
    "objectID": "assessment.html#open",
    "href": "assessment.html#open",
    "title": "BIOE591: Preliminary Assessment",
    "section": "",
    "text": "What are you hoping to get out of this class?\nDo you have your own dataset, or will you be working with an example?\nWhat kind of questions do you want to address with data?\nWhat are you worried about in this class, if anything?\nIs there anything else I should know to help you have a good semester?"
  }
]